// File: cs414Asg3.cpp
// Author: Terrence Gaines A00103977

/*
Grammar:

Statement -> Command  Filename | Command  Foldername | Command
Command -> "ls" | "cd" | "cat" | "print" | "exec"
Filename -> "A-Z" | "a-z" | "0-9"
Foldername -> "A-Z" | "a-z" | "0-9"



start symbol = Statement
*/


#include <iostream>
#include <string>
#include <vector>
#include <cctype>
#include <stdexcept>
#include <regex>

enum class TokenType {
    FILENAME, FOLDERNAME, COMMAND, END
};

struct Token {
    TokenType type;
    std::string value;
};

class Tokenizer {
private:
    std::string input;
    size_t pos;
    Token current;

    // Helper to read a sequence of characters satisfying a predicate
    template<typename Predicate>
    std::string readWhile(Predicate predicate) {
        size_t start = pos;
        while (pos < input.size() && predicate(input[pos])) pos++;
        return input.substr(start, pos - start);
    }

public:
    explicit Tokenizer(const std::string& input) : input(input), pos(0) {
        nextToken();
    }

    Token currentToken() const { return current; }

    void nextToken() {
        // Skip whitespace
        while (pos < input.size() && isspace(input[pos])) pos++;

        if (pos >= input.size()) {
            current = { TokenType::END, "" };
            return;
        }

        // Read the next word
        std::string word = readWhile([](char c) { return !isspace(c); });

        // Define regex patterns
        std::regex filenameRegex(R"([A-Za-z0-9]{8}\.[A-Za-z0-9]{3})");
        std::regex foldernameRegex(R"([A-Za-z0-9]{1,8})");

        // Check for commands
        if (word == "ls" || word == "cd" || word == "cat" || word == "print" || word == "exec") 
        {
            current = { TokenType::COMMAND, word };
        }
        // Check for filename
        else if (std::regex_match(word, filenameRegex)) 
        {
            current = { TokenType::FILENAME, word };
        }
        // Check for foldername (must not match filename)
        else if (std::regex_match(word, foldernameRegex) && !std::regex_match(word, filenameRegex)) 
        {
            current = { TokenType::FOLDERNAME, word };
        }
        else {
            throw std::runtime_error("Unexpected input: " + word);
        }
    }
};

class Parser {
private:
    Tokenizer& tokenizer;

    void expect(TokenType type) {
        if (tokenizer.currentToken().type != type) {
            throw std::runtime_error("Syntax error: expected " +
                std::to_string(static_cast<int>(type)) + ", got " +
                std::to_string(static_cast<int>(tokenizer.currentToken().type)));
        }
        tokenizer.nextToken();
    }

    void parseStmtList() {
        while (tokenizer.currentToken().type != TokenType::END) {
            parseStmt();
        }
    }

    void parseStmt() {
        if (tokenizer.currentToken().type == TokenType::COMMAND) {
            parseCmd();
        }
        else {
            throw std::runtime_error("Syntax error: expected COMMAND, got " +
                std::to_string(static_cast<int>(tokenizer.currentToken().type)));
        }
    }

    void parseCmd() {
        // Print the command
        std::cout << "Command = " << tokenizer.currentToken().value << "\n";
        tokenizer.nextToken(); // Advance past COMMAND

        // Check for optional FILENAME or FOLDERNAME
        if (tokenizer.currentToken().type == TokenType::FILENAME) {
            std::cout << "File name = " << tokenizer.currentToken().value << "\n";
            tokenizer.nextToken();
        }
        else if (tokenizer.currentToken().type == TokenType::FOLDERNAME) {
            std::cout << "Folder name = " << tokenizer.currentToken().value << "\n";
            tokenizer.nextToken();
        }
        // No action needed for END (Command alone is valid)
    }

public:
    explicit Parser(Tokenizer& tokenizer) : tokenizer(tokenizer) {}

    void parse() {
        parseStmtList();
    }
};

int main() {
    std::string input = "cd welcome exec welcomer.txt";
    Tokenizer tokenizer(input);
    Parser parser(tokenizer);

    try {
        parser.parse();
    }
    catch (const std::exception& ex) {
        std::cerr << ex.what() << std::endl;
    }

    return 0;
}



/*
Code Generated by Prompt: 
what is wrong with this c++ code: // File: cs414Asg3.cpp
//Author: Terrence Gaines A00103977


+

Grammar:

Statement -> Command  Filename | Command  Foldername | Command
Command -> "ls" | "cd" | "cat" | "print" | "exec"
Filename -> "A-Z" | "a-z" | "0-9"
Foldername -> "A-Z" | "a-z" | "0-9"



start symbol = Statement





//Based on Sample Code provided in lecture notes

#include <iostream>
#include <string>
#include <vector>
#include <cctype>
#include <unordered_map>
#include <stdexcept>
#include <regex>
#include <array>
#include <sstream>

//Code provided by grok via prompt: Can you build me a mtehod for taking a string and splitting it into an array of its words in c++
std::vector<std::string> splitIntoWords(const std::string& str) {
    std::vector<std::string> words;
    std::stringstream ss(str);
    std::string word;
    while (ss >> word) {
        words.push_back(word);
    }
    return words;
}


enum class TokenType
{
    FILENAME, FOLDERNAME, COMMAND, END
};

struct Token
{
    TokenType type;
    std::string value;

};

class Tokenizer
{
private:
    std::string input;
    size_t pos;
    Token current;

    template<typename Predicate>
    std::string readWhile(Predicate predicate) {
        size_t start = pos;
        while (pos < input.size() && predicate(input[pos])) pos++;
        return input.substr(start, pos - start);
    }

public:
    explicit Tokenizer(const std::string& input) : input(input), pos(0) { nextToken(); }
    Token currentToken() const { return current; }

    void nextToken()
    {
        while (pos < input.size() && isspace(input[pos])) pos++;

        if (pos == input.size())
        {
            current = { TokenType::END, "" };
            return;
        }


        std::vector<std::string> testIn = splitIntoWords(input);
        std::string regStr1 = R"([A-Za-z]{8}.[A-Za-z]{3})";
        std::string regStr2 = R"([A-Za-z0-9]{1,8})";

        std::regex regEx1(regStr1);
        std::regex regEx2(regStr2);




        if (testIn[pos] == "ls")
        {
            current = { TokenType::COMMAND, "ls" };
            return;
        }
        else if (testIn[pos] == "cd")
        {
            current = { TokenType::COMMAND, "cd" };
            return;
        }
        else if (testIn[pos] == "cat")
        {
            current = { TokenType::COMMAND, "cat" };
            return;
        }
        else if (testIn[pos] == "print")
        {
            current = { TokenType::COMMAND, "print" };
            return;
        }
        else if (testIn[pos] == "exec")
        {
            current = { TokenType::COMMAND, "exec" };
            return;
        }
        else if (std::regex_match(testIn[pos], regEx1))
        {
            current = { TokenType::FILENAME, testIn[pos] };
            return;
        }
        else if (std::regex_match(testIn[pos], regEx2))
        {
            current = { TokenType::FOLDERNAME, testIn[pos] };
            return;
        }
        else
        {
            throw std::runtime_error("Unexpected Input");
        }

        pos++;
    }
};



class Parser
{
private:

    Tokenizer& tokenizer;

    void expect(TokenType type)
    {
        if (tokenizer.currentToken().type != type)
        {
            throw std::runtime_error("Syntax error: unexpected token");
        }
        tokenizer.nextToken();
    }

    void parseStmtList()
    {
        while (tokenizer.currentToken().type != TokenType::END)
        {
            parseStmt();
        }
    }

    void parseStmt()
    {
        if (tokenizer.currentToken().type == TokenType::COMMAND)
        {
            parseCmd();
        }

        else
        {
            throw std::runtime_error("Syntax error: invalid statement");
        }

    }

    void parseCmd()
    {

        if (tokenizer.currentToken().value == "ls")
        {
            std::cout << "Command = ls\n";
        }

        else if (tokenizer.currentToken().value == "cd")
        {
            std::cout << "Command = cd\n";
        }

        else if (tokenizer.currentToken().value == "cat")
        {
            std::cout << "Command = cat\n";
        }

        else if (tokenizer.currentToken().value == "print")
        {
            std::cout << "Command = print\n";
        }

        else if (tokenizer.currentToken().value == "exec")
        {
            std::cout << "Command = exec\n";
        }


        expect(TokenType::COMMAND);

        if (tokenizer.currentToken().type == TokenType::FILENAME)
        {
            std::cout << "File name = " << tokenizer.currentToken().value << std::endl;
            tokenizer.nextToken(); //Token advancement suggested by Grok debugging
        }

        else if (tokenizer.currentToken().type == TokenType::FOLDERNAME)
        {
            std::cout << "Folder name = " << tokenizer.currentToken().value << std::endl;
            tokenizer.nextToken(); //Token advancement suggested by Grok debugging
        }

        else
        {
            throw std::runtime_error("Syntax error: invalid statement");
        }
    }



public:
    explicit Parser(Tokenizer& tokenizer) : tokenizer(tokenizer) {}

    void parse() {
        parseStmtList();
    }
};






int main()
{
    std::string input = "cd welcome exec welcomer.txt";
    Tokenizer tokenizer(input);
    Parser parser(tokenizer);

    try {
        parser.parse();
    }
    catch (const std::exception& ex) {
        std::cerr << ex.what() << std::endl;
    }

    return 0;


}
*/