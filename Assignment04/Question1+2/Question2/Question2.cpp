//File: Question2.cpp
// Author: Terrence Gaines A00103977
//Code generated by ChatGPT using old code and question as prompt

/*
Question 1:
Grammar (Generated by ChatGPT):

Statement -> Command
          | Command Argument
          | SetStatement
          | EchoStatement

Command -> "ls"
        | "cd"
        | "cat"
        | "print"
        | "exec"

Argument -> Identifier
         | Variable

Identifier -> Letter
           | Identifier Letter
           | Identifier Digit

Letter -> "A" | … | "Z"
       | "a" | … | "z"

Digit -> "0" | … | "9"

Variable -> "$" Identifier

SetStatement -> "SET" Variable "=" Expr

EchoStatement -> "echo" Variable

Expr -> Expr "+" Term
     | Expr "-" Term
     | Term

Term -> Term "*" Factor
     | Term "/" Factor
     | Factor

Factor -> Number
       | Variable
       | "(" Expr ")"

Number -> Digit
       | Number Digit

Start Symbol = Statement
*/

#include <iostream>
#include <string>
#include <vector>
#include <cctype>
#include <stdexcept>
#include <regex>
#include <unordered_map>

// ------------------------- TOKEN DEFINITIONS -------------------------
enum class TokenType {
    COMMAND,
    IDENTIFIER,
    VARIABLE,
    NUMBER,
    PLUS, MINUS, MUL, DIV,
    LPAREN, RPAREN,
    SET, ECHO, ASSIGN,
    END
};

struct Token {
    TokenType type;
    std::string value;
};

// ------------------------- TOKENIZER ---------------------------------
class Tokenizer {
private:
    std::string input;
    size_t pos;
    Token current;

    bool isLetter(char c) { return std::isalpha((unsigned char)c); }
    bool isDigit(char c) { return std::isdigit((unsigned char)c); }

public:
    explicit Tokenizer(const std::string& input) : input(input), pos(0) {
        nextToken();
    }

    Token currentToken() const { return current; }

    void skipWS() {
        while (pos < input.size() && std::isspace(input[pos])) pos++;
    }

    // Read identifier (letters/digits)
    std::string readIdentifier() {
        size_t start = pos;
        while (pos < input.size() && (isLetter(input[pos]) || isDigit(input[pos]))) pos++;
        return input.substr(start, pos - start);
    }

    // Read number (digits only)
    std::string readNumber() {
        size_t start = pos;
        while (pos < input.size() && isDigit(input[pos])) pos++;
        return input.substr(start, pos - start);
    }

    void nextToken() {
        skipWS();

        if (pos >= input.size()) {
            current = { TokenType::END, "" };
            return;
        }

        char c = input[pos];

        // Keywords / Commands / Identifiers
        if (isLetter(c)) {
            std::string word = readIdentifier();

            if (word == "SET") { current = { TokenType::SET, word }; return; }
            if (word == "echo") { current = { TokenType::ECHO, word }; return; }

            // original cmds
            if (word == "ls" || word == "cd" || word == "cat" ||
                word == "print" || word == "exec") {
                current = { TokenType::COMMAND, word };
                return;
            }

            // otherwise IDENTIFIER
            current = { TokenType::IDENTIFIER, word };
            return;
        }

        // Variable
        if (c == '$') {
            pos++;
            std::string name = readIdentifier();
            if (name.empty()) throw std::runtime_error("Invalid variable name");
            current = { TokenType::VARIABLE, "$" + name };
            return;
        }

        // Numbers
        if (isDigit(c)) {
            current = { TokenType::NUMBER, readNumber() };
            return;
        }

        // Operators and punctuation
        switch (c) {
        case '+': pos++; current = { TokenType::PLUS, "+" }; return;
        case '-': pos++; current = { TokenType::MINUS, "-" }; return;
        case '*': pos++; current = { TokenType::MUL, "*" }; return;
        case '/': pos++; current = { TokenType::DIV, "/" }; return;
        case '(': pos++; current = { TokenType::LPAREN, "(" }; return;
        case ')': pos++; current = { TokenType::RPAREN, ")" }; return;
        case '=': pos++; current = { TokenType::ASSIGN, "=" }; return;
        }

        throw std::runtime_error(std::string("Unexpected character: ") + c);
    }
};

// ------------------------- PARSER -----------------------------------

class Parser {
private:
    Tokenizer& tokenizer;

    // Symbol table: variable -> string value
    std::unordered_map<std::string, std::string> symTable;

public:
    explicit Parser(Tokenizer& tokenizer) : tokenizer(tokenizer) {}

    // ---------- Utility ----------
    void expect(TokenType type) {
        if (tokenizer.currentToken().type != type)
            throw std::runtime_error("Expected different token type");

        tokenizer.nextToken();
    }

    // ---------- Grammar ----------
    void parse() {
        while (tokenizer.currentToken().type != TokenType::END) {
            parseStatement();
            printSymbolTable();
        }
    }

    void parseStatement() {
        Token tok = tokenizer.currentToken();

        if (tok.type == TokenType::COMMAND) {
            parseCommand();
            return;
        }
        if (tok.type == TokenType::SET) {
            parseSet();
            return;
        }
        if (tok.type == TokenType::ECHO) {
            parseEcho();
            return;
        }

        throw std::runtime_error("Syntax error at statement level");
    }

    void parseCommand() {
        std::cout << "Command = " << tokenizer.currentToken().value << "\n";
        tokenizer.nextToken();

        // Optional argument (identifier or variable)
        TokenType t = tokenizer.currentToken().type;
        if (t == TokenType::IDENTIFIER || t == TokenType::VARIABLE) {
            std::cout << "Argument = " << tokenizer.currentToken().value << "\n";
            tokenizer.nextToken();
        }
    }

    void parseSet() {
        expect(TokenType::SET);

        if (tokenizer.currentToken().type != TokenType::VARIABLE)
            throw std::runtime_error("SET must be followed by a variable");

        std::string varName = tokenizer.currentToken().value;
        tokenizer.nextToken();

        expect(TokenType::ASSIGN);

        // Read the raw expression string for storage
        std::string expr = parseExpr();

        // store it as-is
        symTable[varName] = expr;

        std::cout << "SET " << varName << " = " << expr << "\n";
    }

    void parseEcho() {
        expect(TokenType::ECHO);

        if (tokenizer.currentToken().type != TokenType::VARIABLE)
            throw std::runtime_error("echo expects a variable");

        std::string var = tokenizer.currentToken().value;
        tokenizer.nextToken();

        std::cout << "echo " << var << "\n";
    }

    // ---------- Expression Parsing (no evaluation) ----------
    std::string parseExpr() {
        std::string left = parseTerm();
        while (tokenizer.currentToken().type == TokenType::PLUS ||
            tokenizer.currentToken().type == TokenType::MINUS) {
            std::string op = tokenizer.currentToken().value;
            tokenizer.nextToken();
            std::string right = parseTerm();
            left += " " + op + " " + right;
        }
        return left;
    }

    std::string parseTerm() {
        std::string left = parseFactor();
        while (tokenizer.currentToken().type == TokenType::MUL ||
            tokenizer.currentToken().type == TokenType::DIV) {
            std::string op = tokenizer.currentToken().value;
            tokenizer.nextToken();
            std::string right = parseFactor();
            left += " " + op + " " + right;
        }
        return left;
    }

    std::string parseFactor() {
        Token tok = tokenizer.currentToken();

        if (tok.type == TokenType::NUMBER || tok.type == TokenType::VARIABLE) {
            tokenizer.nextToken();
            return tok.value;
        }

        if (tok.type == TokenType::LPAREN) {
            tokenizer.nextToken();
            std::string inside = parseExpr();
            expect(TokenType::RPAREN);
            return "(" + inside + ")";
        }

        throw std::runtime_error("Unexpected factor");
    }

    // ---------- Symbol Table Output ----------
    void printSymbolTable() {
        std::cout << "--- Symbol Table ---\n";
        for (auto& p : symTable)
            std::cout << p.first << " = " << p.second << "\n";
        std::cout << "--------------------\n";
    }
};

// ------------------------- MAIN -------------------------------------

int main() {
    std::string input =
        "SET $A = 10 + 20\n"
        "echo $A\n"
        "SET $B = ($A + 5) * 3\n"
        "ls $B";

    Tokenizer tokenizer(input);
    Parser parser(tokenizer);

    try {
        parser.parse();
    }
    catch (const std::exception& ex) {
        std::cerr << "Error: " << ex.what() << "\n";
    }
}
