// File: Question1.cpp 
// Author: Terrence A00103977
// Generated by Grok using Part 1 as initial prompt

#include <iostream>
#include <vector>
#include <chrono>
#include <functional>
#include <string>
#include <algorithm>

class SortStrategy {
public:
    virtual ~SortStrategy() = default;
    virtual void sort(std::vector<int>& data) = 0;
};

class BubbleSort : public SortStrategy {
public:
    void sort(std::vector<int>& data) override {
        for (size_t i = 0; i < data.size(); ++i) {
            for (size_t j = 0; j < data.size() - i - 1; ++j) {
                if (data[j] > data[j + 1]) {
                    std::swap(data[j], data[j + 1]);
                }
            }
        }
    }
};

class MergeSort : public SortStrategy {
private:
    void merge(std::vector<int>& data, int left, int mid, int right) {
        std::vector<int> temp(right - left + 1);
        int i = left, j = mid + 1, k = 0;
        while (i <= mid && j <= right) {
            if (data[i] <= data[j]) {
                temp[k++] = data[i++];
            }
            else {
                temp[k++] = data[j++];
            }
        }
        while (i <= mid) {
            temp[k++] = data[i++];
        }
        while (j <= right) {
            temp[k++] = data[j++];
        }
        for (k = 0; k < temp.size(); ++k) {
            data[left + k] = temp[k];
        }
    }

    void merge_sort(std::vector<int>& data, int left, int right) {
        if (left >= right) return;
        int mid = left + (right - left) / 2;
        merge_sort(data, left, mid);
        merge_sort(data, mid + 1, right);
        merge(data, left, mid, right);
    }

public:
    void sort(std::vector<int>& data) override {
        merge_sort(data, 0, static_cast<int>(data.size()) - 1);
    }
};

class QuickSort : public SortStrategy {
private:
    int partition(std::vector<int>& data, int low, int high) {
        int pivot = data[high];
        int i = low - 1;
        for (int j = low; j < high; ++j) {
            if (data[j] < pivot) {
                ++i;
                std::swap(data[i], data[j]);
            }
        }
        std::swap(data[i + 1], data[high]);
        return i + 1;
    }

    void quick_sort(std::vector<int>& data, int low, int high) {
        if (low < high) {
            int pi = partition(data, low, high);
            quick_sort(data, low, pi - 1);
            quick_sort(data, pi + 1, high);
        }
    }

public:
    void sort(std::vector<int>& data) override {
        quick_sort(data, 0, static_cast<int>(data.size()) - 1);
    }
};

class SortContext {
private:
    std::function<void(std::vector<int>&)> strategy_func;

public:
    void set_strategy(SortStrategy* s) {
        strategy_func = [s](std::vector<int>& d) { s->sort(d); };
    }

    void set_strategy(std::function<void(std::vector<int>&)> f) {
        strategy_func = f;
    }

    void execute_strategy(std::vector<int>& data) {
        auto start = std::chrono::high_resolution_clock::now();
        if (strategy_func) {
            strategy_func(data);
        }
        auto end = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double, std::milli> elapsed = end - start;
        std::cout << "Execution time: " << elapsed.count() << " ms" << std::endl;
    }
};

int main(int argc, char* argv[]) {
    std::vector<int> original = { 5, 2, 9, 1, 5, 6 };

    QuickSort quick;
    MergeSort merge;
    BubbleSort bubble;

    auto insertion = [](std::vector<int>& data) {
        for (size_t i = 1; i < data.size(); ++i) {
            int key = data[i];
            size_t j = i;
            while (j > 0 && data[j - 1] > key) {
                data[j] = data[j - 1];
                --j;
            }
            data[j] = key;
        }
        };

    SortContext context;

    // Run and compare all strategies
    std::cout << "QuickSort:" << std::endl;
    auto data1 = original;
    context.set_strategy(&quick);
    context.execute_strategy(data1);
    for (int n : data1) std::cout << n << " ";
    std::cout << std::endl << std::endl;

    std::cout << "MergeSort:" << std::endl;
    auto data2 = original;
    context.set_strategy(&merge);
    context.execute_strategy(data2);
    for (int n : data2) std::cout << n << " ";
    std::cout << std::endl << std::endl;

    std::cout << "BubbleSort:" << std::endl;
    auto data3 = original;
    context.set_strategy(&bubble);
    context.execute_strategy(data3);
    for (int n : data3) std::cout << n << " ";
    std::cout << std::endl << std::endl;

    std::cout << "InsertionSort (lambda):" << std::endl;
    auto data4 = original;
    context.set_strategy(insertion);
    context.execute_strategy(data4);
    for (int n : data4) std::cout << n << " ";
    std::cout << std::endl << std::endl;

    // Dynamic selection from command-line
    if (argc > 1) {
        std::string arg = argv[1];
        auto data = original;
        bool valid = true;

        if (arg == "quick") {
            context.set_strategy(&quick);
        }
        else if (arg == "merge") {
            context.set_strategy(&merge);
        }
        else if (arg == "bubble") {
            context.set_strategy(&bubble);
        }
        else if (arg == "insertion") {
            context.set_strategy(insertion);
        }
        else {
            valid = false;
            std::cout << "Unknown strategy: " << arg << std::endl;
        }

        if (valid) {
            std::cout << "Selected strategy (" << arg << "):" << std::endl;
            context.execute_strategy(data);
            for (int n : data) std::cout << n << " ";
            std::cout << std::endl;
        }
    }

    return 0;
}